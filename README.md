# Обоснование выбора языка

`Степанов Арсений Алексеевич - 368849`

За свою практику коммерческого программирования я имел возможность поработать с
довольно обширным набором языков программирования и разметки: от `ассемблера`
до `Terraform`'a. Однако функциональных языков на практике мне не
приходилось использовать ни разу не считая небольших проектов на `Rust` или
`F#`, но опять же назвать их чисто функциональными нельзя. Поэтому в поисках
языка, который бы позволил мне глубже погрузиться в функциональную парадигму
и при этом не был достаточно *академическим* (как например `Idris` или `Agda`)
чтобы быть непрактичным для промышленного использования, я остановился на
следующих вариантах:

- `Haskell` - пожалуй самый известный функциональный язык, с богатой историей и
  большим сообществом. Однако его синтаксис и особенности реализации (ленивые
  вычисления, сложная система типов) могут показаться довольно сложными и
  задать высокий порог входа
- `OCaml` - язык с сильной статической типизацией и поддержкой
  объектно-ориентированного программирования. Он имеет более простой синтаксис
  по сравнению с `Haskell` и используется в промышленности, например в
  финансовом секторе
- `F#` - функциональный язык, работающий на платформе `.NET`. Он сочетает в
  себе функциональные и императивные парадигмы, что может быть полезно для тех,
  кто привык к более традиционным языкам программирования. Однако его
  экосистема тесно связана с `.NET`, что может ограничить выбор инструментов и
  библиотек (я настрадался и не хочу использовать `Visual Studio`)

Из предложенных вариантов я хотел бы выбрать `Haskell`, так как он наиболее
известен и имеет богатую экосистему библиотек, что делает его подходящим для
решения задач различного спектра. Кроме того, его ленивые вычисления и мощная
система типов позволяют создавать надежные и лаконичные программы

В качестве проекта мне бы хотелось сделать что-то практическое и, так как язык
располагает, связанное непосредственно с математикой. Поэтому я хотел бы
написать небольшую и простую библиотеку для реализации глубокого обучения

## Материалы для изучения

В качестве материалов для изучения `Haskell`'а я планирую использовать
официальную документацию, а так же рекомендуемую литературу с
[Haskell Wiki](https://wiki.haskell.org/Books_and_tutorials). В частности
книгу Аллена и Джули Моронуки `Haskell Programming from First Principles`

## Используемый инструментарий

### Компилятор

`GHC` (Glasgow Haskell Compiler) — основной компилятор Haskell. Обеспечивает
строгую статическую типизацию, мощную систему оптимизаций, поддержку расширений
языка, а также работу с системой типов, гарантирующей многие свойства программ
на этапе компиляции

### Система сборки

- `Cabal` — стандартный инструмент для сборки и управления пакетами в Haskell.
  Позволяет описывать зависимости, конфигурации сборки, тесты, бенчмарки и
  собирать проект
- `Stack` — надстройка над Cabal, с более предсказуемым управлением версиями
  GHC, зависимостей

### Инструменты для автоматического форматирования

- `Ormolu` — популярный форматтер кода, с минимальной конфигурацией,
  направленный на единообразие и читаемость
- `Fourmolu` — ответвление от Ormolu, иногда с дополнительными возможностями
  (в зависимости от сообщества)
- `Brittany` — более гибкий форматтер, который допускает конфигурацию стиля
  (отступы, правило переносов и др.)

### Линтеры и статический анализ

- `HLint` — инструмент, проверяющий код на распространённые стилистические
  *ошибки*, *дубликаты*, *неиспользуемые выражения* и предлагающий различные
  улучшения для рефакторинга
- Включение предупреждений компилятора GHC, например -Wall, и, по возможности,
  -Werror, чтобы предупреждения не оставались незамеченными

### Инструменты для тестирования

- `QuickCheck` — библиотека для property-based тестирования, позволяет задавать
  свойства, а тестовые данные генерируются автоматически
- `Hspec` — удобный фреймворк для описания *спецификаций / тестов*,
  похожий по стилю на RSpec
- `HUnit` — более простой, классический фреймворк для модульных тестов
- `Tasty` — гибкий тестовый фреймворк, который позволяет комбинировать разные
  типы тестов (unit, property-based, benchmark, golden tests и др.)

### Стиль кодирования

- Руководства стиля, такие как
  [Haskell Style Guide](https://wiki.haskell.org/Programming_guidelines)
- Использование snake_case для имен функций и переменных, CamelCase для типов
  и конструкторов типов (алгебраических типов, data и newtype)
